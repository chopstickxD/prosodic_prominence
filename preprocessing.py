import glob
import csv
import scipy.io.wavfile as wav
import numpy as np
from features import mfcc

'''
readAudio creates an array which contains tuples of
(sample rate, signal, name)
sample rate is an int
signal is an array(signal, dtype)
name is a string

Input: pathName - dir in form of a String
Output data - the array with the tuples
'''
def readAudio(pathName):
    #my pathname: '/home/huynh-tan/Dokumente/Bachelor_Thesis/audio_data/CNE/*16k.wav'
    #working only on the 16k datas at first
    data = []
    for name in glob.glob(pathName):
        #iterate the pathName backwards, to get data name
        subStringEnd = name[len(name)-1]
        dataName = ''
        counter = len(name)-1
        while (subStringEnd != '/'):
            dataName += name[counter]
            counter  = counter - 1
            subStringEnd = name[counter]
        #dataName is reversed, with [::-1] its in the correct order
        dataName = dataName[::-1]
        (rate, sig) = wav.read(name)
        #[:-8] to delete the last 8 chars '_16k.wav'
        data.append((rate, sig, dataName[:-8]))
    return data


'''
As the name says gets the specific data point

Input: dataSet - a dataSet which is generated by makeLabels, makeMfcc or read_audio
       name - name of a data point
       pos - 0 for labels, 1 for feature data, 2 for audi data
'''
def getElement(dataSet, name, type):
    wanted = []
    for data in dataSet:
        if(data[type] == name):
            wanted = data
    return wanted


'''
makes a MFCC  data Set which looks like this
[(mfcc_feats1),name1),(mfcc_feats2),name2), ..., (mfcc_featsN),nameN)]

Input: dataSet - a dataSet which is generated by readAudio
Output: MFCC data set as described
'''
def makeMFCC_dataSet(dataSet):
    mfcc_dataSet = []
    for data in dataSet:
        mfcc_feat = mfcc(data[1], data[0])
        mfcc_dataSet.append([mfcc_feat, data[2]])
    return mfcc_dataSet


'''
makeLabels creates an array like [['name1', [label1]], ['name2', [label2]], ...]
which contains the label to the corresponding name

Input: pathName - Path as string to the .csv file
Output: labels - array like described
'''
def makeLabels(pathName):
    with open(pathName, 'rt') as f:
        reader = csv.reader(f, delimiter=',')
        labels = []
        for row in reader:
            labels = row
            del labels[-1]
        for n in range(len(labels)):
            #labels[n] is a string 'name label', with split I get a tuple ('name', 'label')
            labels[n] = labels[n].split(' ', 1)
            #label looks like this '[0 0 0 0 1]', now remove '[ ]' and make an int array
            labelName = labels[n][1]
            labelName = labelName.strip('[ ]')
            labels[n][1] = list(map(int, labelName.split(' ')))
            if (len(labels[n][1])<5):
                labels[n][1] = np.pad(labels[n][1], (0, 5-len(labels[n][1])), 'constant', constant_values=(0, 0))
    return labels

'''
makeInputs creates an array which contains the signal as mfcc and the corresponding label

Input: pathData, pathLabel - path to the data and labels as string
Output: inputData - an array like this [[array(mfccs1),[label1]], [array(mfccs2),[label2]], ...]
'''
def makeInput(pathData, pathLabel):
    audioSet = readAudio(pathData)
    labelSet = makeLabels(pathLabel)
    mfccSet = makeMFCC_dataSet(audioSet)
    inputData = []
    for feature in mfccSet:
        #just get the label without name
        label = getElement(labelSet, feature[1], 0)[1]
        inputPair = [feature[0], label]
        inputData.append(inputPair)
    return inputData


'''
beginningTime - [time1, time2, time3, time4, time5]
word- and sentenceTime - an Integer
sampleRate = 16000 #for now will be edited later
sentenceTime = max dauer ca. 9Sek
    maxStep = sentenceTime/sampleRate

for testing: beginningTime = [0.5, 0.9, 1.2, 1.5, 1.9] -> beginningStep = [8000, 14400, 19200, 24000, 30400]
             wordStep = [0.3->4800] maxStep = [4 -> 64000]
'''
def makeSequence(dataSet, beginningStep, wordStep, maxStep, sampleRate):
    #[(sample rate, signal, name).. ]
    sequenceSet = []
    for data in dataSet:
        sig = data[1]
        if (len(sig) > maxStep):
            sig = sig[0:maxStep]
        else:
            sig = np.pad(sig, (0, maxStep - len(sig)), 'constant', constant_values=(0, 0))
        signal_n = []
        for begin_i in beginningStep:
            word_n = sig[begin_i:(begin_i+wordStep)]
            mfcc_n = mfcc(word_n, sampleRate)
            signal_n.append(mfcc_n)
        sequenceSet.append((signal_n, data[2]))
    return sequenceSet

'''
Output: [[5words*29frames*13mfcc],[label], ...] lenOutput -> data size
'''
def matchSeq2Label(sequenceSet, labelSet):
    seqWithLabel = []
    for seq in sequenceSet:
        # just get the label without name
        label = getElement(labelSet, seq[1], 0)[1]
        inputPair = [seq[0], label]
        seqWithLabel.append(inputPair)
    return seqWithLabel
'''

Output: [[(numframes*13mfcc), labelword], ...] lenOutput -> 5words*dataSize
'''
def matchWord2Label(seqWithLabel):
    word2label = []
    for swl in seqWithLabel:
        oneWord = []
        for i in range(len(swl[0])):
            aWord = swl[0][i]
            aLabel = swl[1][i]
            word2label.append([aWord, aLabel])
    return word2label

def makeInputSeq(pathData, pathLabel, beginningStep, wordStep, maxStep, sampleRate):
    audioSet = readAudio(pathData)
    labelSet = makeLabels(pathLabel)
    seqSet = makeSequence(audioSet, beginningStep, wordStep, maxStep, sampleRate)
    seq2label = matchSeq2Label(seqSet, labelSet)
    word2label = matchWord2Label(seq2label)
    examples = []
    labels = []
    for arg in word2label:
        '''
        labels prominent[0,1] notProminent[1,0]
        '''
        examples.append(arg[0])
        if arg[1] == 0:
            labels.append([1, 0])
        else:
            labels.append([0, 1])

    return np.asarray(examples), np.asarray(labels)



'''
Here starts something like the main():
'''


pathData = '/home/huynh-tan/Dokumente/Bachelor_Thesis/audio_data/HRO/*16k.wav'
pathLabel = '/home/huynh-tan/Dokumente/Bachelor_Thesis/Labels/Labels_as_csv/labels_HRO.csv'

#audio = readAudio(pathData)
beginningStep = [8000, 14400, 19200, 24000, 30400]
wordStep = 4800
maxStep = 64000
sampleRate = 16000
#seq = makeSequence(audio, beginningStep, wordStep, maxStep, sampleRate)
#seq2label = matchSeq2Label(seq, makeLabels(pathLabel))
#word2Label = matchWord2Label(seq2label)
#examples, labels = makeInputSeq(pathData, pathLabel, beginningStep, wordStep, maxStep, sampleRate)
#print(len(examples))
#print(len(labels))
#print('example   ', examples.shape)
#print('label all  ', labels.shape)
#print('label   ', labels[1000].shape)
#print('label   ', labels[0:100])
#print('ALLES', seq2label)
#print(seq[3])
#inputSet = makeInput(pathData, pathLabel)
#labels = makeLabels(pathLabel)
#audio = readAudio(pathData)

#print(len(inputSet[0][0]))
#print(audio)
#label = getElement(labels, '000001-prompt', 0)
#print(label)
