import glob
import csv
import scipy.io.wavfile as wav
import numpy as np
from features import mfcc

'''
readAudio creates an array which contains tuples of
(sample rate, signal, name)
sample rate is an int
signal is an array(signal, dtype)
name is a string

Input: pathName - dir in form of a String
Output data - the array with the tuples
'''
def readAudio(pathName):
    #my pathname: '/home/huynh-tan/Dokumente/Bachelor_Thesis/audio_data/CNE/*16k.wav'
    #working only on the 16k datas at first
    data = []
    for name in glob.glob(pathName):
        #iterate the pathName backwards, to get data name
        subStringEnd = name[len(name)-1]
        dataName = ''
        counter = len(name)-1
        while (subStringEnd != '/'):
            dataName += name[counter]
            counter  = counter - 1
            subStringEnd = name[counter]
        #dataName is reversed, with [::-1] its in the correct order
        dataName = dataName[::-1]
        (rate, sig) = wav.read(name)
        #[:-8] to delete the last 8 chars '_16k.wav'
        data.append((rate, sig, dataName[:-8]))
    return data

'''
As the name says gets the specific data point

Input: dataSet - a dataSet which is generated by makeLabels, makeMfcc or read_audio
       name - name of a data point
       pos - 0 for labels/startEndTimes, 1 for feature data, 2 for audio data
'''
def getElement(dataSet, name, type):
    wanted = []
    for data in dataSet:
        if(data[type] == name):
            wanted = data
    return wanted


'''
makes a MFCC  data Set which looks like this
[(mfcc_feats1),name1),(mfcc_feats2),name2), ..., (mfcc_featsN),nameN)]

Input: dataSet - a dataSet which is generated by readAudio [(sample rate, signal, name),...]
Output: MFCC data set as described
'''
def makeMFCC_dataSet(dataSet):
    mfcc_dataSet = []
    for data in dataSet:
        mfcc_feat = mfcc(data[1], data[0])
        mfcc_dataSet.append([mfcc_feat, data[2]])
    return mfcc_dataSet


'''
makeLabels creates an array like [['name1', [label1]], ['name2', [label2]], ...]
which contains the label to the corresponding name

Input: pathName - Path as string to the .csv file
Output: labels - array like described
'''
def makeLabels(pathName):
    with open(pathName, 'rt') as f:
        reader = csv.reader(f, delimiter=',')
        labels = []
        for row in reader:
            labels = row
            del labels[-1]
        for n in range(len(labels)):
            #labels[n] is a string 'name label', with split I get a tuple ('name', 'label')
            labels[n] = labels[n].split(' ', 1)
            #label looks like this '[0 0 0 0 1]', now remove '[ ]' and make an int array
            labelName = labels[n][1]
            labelName = labelName.strip('[ ]')
            labels[n][1] = list(map(int, labelName.split(' ')))
            if (len(labels[n][1])<5):
                labels[n][1] = np.pad(labels[n][1], (0, 5-len(labels[n][1])), 'constant', constant_values=(0, 0))
    return labels

'''
makesStartEnd_TimeLabels creates an array like [['name1', [startT], [endT]], ['name2', [startT2], [endT2]], ...]
which contains the start and end times to the corresponding name

Input: pathName - Path as string to the .csv file
Output: times - array like described
'''
def makeStartEndTime(pathName, sampleRate):
    with open(pathName, 'rt') as t:
        reader = csv.reader(t, delimiter=',')
        times = []
        for row in reader:
            times = row
            del times[-1]
        for n in range(len(times)):
            times[n] = times[n].split(' ')

            startTime = times[n][1]
            startTime = startTime.strip('[ ]')
            times[n][1] = list(map(float, startTime.split(';')))

            endTime = times[n][2]
            endTime = endTime.strip('[ ]')
            times[n][2] = list(map(float, endTime.split(';')))

            for m in range(len(times[n][1])):
                times[n][1][m] = int(times[n][1][m]*sampleRate)
                times[n][2][m] = int(times[n][2][m]*sampleRate)
            #print(times[n][0])
            '''
            if (len(times[n][1])<5):
                times[n][1] = np.pad(times[n][1], (0, 5-len(times[n][1])), 'constant', constant_values=(0, 0))
                times[n][1] = np.pad(times[n][2], (0, 5-len(times[n][1])), 'constant', constant_values=(0, 0))
            '''
    return times




'''
beginningTime - [time1, time2, time3, time4, time5]
word- and sentenceTime - an Integer
sampleRate = 16000 #for now will be edited later
sentenceTime = max dauer ca. 9Sek
    maxStep = sentenceTime/sampleRate

for testing: beginningTime = [0.5, 0.9, 1.2, 1.5, 1.9] -> beginningStep = [8000, 14400, 19200, 24000, 30400]
             wordStep = [0.3->4800] maxStep = [4 -> 64000]



dataSet - audioDatas
times - [[name, startTime, endTime], ...]
output
'''

def makeSequence(dataSet, times, maxSentenceStep, maxWordStep, sampleRate):
    #[(sample rate, signal, name).. ]
    sequenceSet = []
    for data in dataSet:
        sig = data[1] #data: [rate, sig, name]
        #print(data[2])
        time_data = getElement(times, data[2], 0)
        #print(time_data)
        starts = time_data[1]
        ends = time_data[2]
        if (len(sig) > maxSentenceStep):
            sig = sig[0:maxSentenceStep]
        else:
            #print('diff1', int(maxSentenceStep - len(sig)))
            sig = np.pad(sig, (0, int(maxSentenceStep - len(sig))), 'constant', constant_values=(0, 0))
        signal_n = []
        for n in range(len(starts)):
            word_n = sig[starts[n]:ends[n]]
            if len(word_n)>maxWordStep:
                word_n = word_n[0:maxWordStep]
            else:
                #print('diff2', maxWordStep - len(word_n))
                word_n = np.pad(word_n, (0, int(maxWordStep - len(word_n))), 'constant', constant_values=(0, 0))
            mfcc_n = mfcc(word_n, sampleRate)
            signal_n.append(mfcc_n)
        sequenceSet.append((signal_n, data[2]))
    return sequenceSet



'''
Output: [[5words*29frames*13mfcc],[label], ...] lenOutput -> data size
'''
def matchSeq2Label(sequenceSet, labelSet):
    seqWithLabel = []
    for seq in sequenceSet:
        # just get the label without name
        # at pos[0] is the name, at pos[1] is the label
        label = getElement(labelSet, seq[1], 0)[1]
        inputPair = [seq[0], label]
        seqWithLabel.append(inputPair)
    return seqWithLabel

'''
Input: [[[5words*29frames*13mfcc],[label]], ...]
Output: [[(numframes*13mfcc), labelword], 5words*29frames*13mfcc],[label]...] lenOutput -> 5words*dataSize
'''
def matchWord2Label(seqWithLabel):
    word2label = []
    for swl in seqWithLabel:
        oneWord = []
        for i in range(len(swl[0])):
            aWord = swl[0][i]
            aLabel = swl[1][i]
            word2label.append([aWord, aLabel])
    return word2label

'''

'''
def makeInputSeq(pathData, pathTimes, pathLabel, maxSentenceStep, maxWordStep, sampleRate):
    audioSet = readAudio(pathData)
    labelSet = makeLabels(pathLabel)
    times = makeStartEndTime(pathTimes, sampleRate)
    seqSet = makeSequence(audioSet, times, maxSentenceStep, maxWordStep, sampleRate)
    seq2label = matchSeq2Label(seqSet, labelSet)
    word2label = matchWord2Label(seq2label)
    promExamples = []
    promLabels = []

    nonpromExamples = []
    nonpromLabels = []
    for arg in word2label:
        '''
        labels prominent[0,1] notProminent[1,0]
        '''

        if arg[1] == 1:
            nonpromLabels.append([0, 1])
            nonpromExamples.append(arg[0])
        else:
            promLabels.append([1, 0])
            promExamples.append(arg[0])
    while len(nonpromExamples)<=len(promExamples):
        del promExamples[-1]
        del promLabels[-1]


    examples = np.concatenate((promExamples, nonpromExamples))
    labels = np.concatenate((promLabels, nonpromLabels))

    return np.asarray(examples), np.asarray(labels)



'''
Here starts something like the main():
'''

pathTimes = '/home/huynh-tan/Dokumente/Bachelor_Thesis/Labels/StartEndTime_as_csv/startEnd_time_CNE.csv'
pathData = '/home/huynh-tan/Dokumente/Bachelor_Thesis/audio_data/CNE/*16k.wav'
pathLabel = '/home/huynh-tan/Dokumente/Bachelor_Thesis/Labels/Labels_as_csv/labels_CNE.csv'


beginningStep = [8000, 14400, 19200, 24000, 30400]
maxWordStep = int(0.35*16000)
maxSentenceStep = 9*16000
sampleRate = 16000
#makeLabels(pathLabel)
#audio = readAudio(pathData)
#times = makeStartEndTime(pathTimes, 16000)
#print('Got it', getElement(times, '000196-correction', 0))

#seq2 = makeSequence2(audio, times, maxSentenceStep, maxWordStep, sampleRate)
#print(getElement(times, '000095-correction', 0))
#examples, labels = makeInputSeq(pathData, pathTimes, pathLabel, maxSentenceStep, maxWordStep, sampleRate)
#print(examples.shape)
#print(len(examples[0]))
#print(len(examples[0][0]))
#print(len(labels))
#print(examples[1])
#print(labels[1])


#seq = makeSequence(audio, beginningStep, wordStep, maxStep, sampleRate)
#seq2label = matchSeq2Label(seq, makeLabels(pathLabel))
#word2Label = matchWord2Label(seq2label)
#examples, labels = makeInputSeq(pathData, pathLabel, beginningStep, wordStep, maxStep, sampleRate)
